 void _botTurn() async {
    await Future.delayed(const Duration(seconds: 2));
    if (!mounted) return;

    int moveIdx = _calculateBestBotMove();

    setState(() {
      if (moveIdx != -1) {
        AnimeCard botCard = opponentHand.removeAt(moveIdx);
        if (botCard.color == Colors.black) {
          botCard.color = _getBestColorForBot(); // Scelta colore logica
        }
        lastPlayedCard = botCard;
        _applyPower(botCard.power, true);
        
        if (opponentHand.isEmpty) {
          _showEndGame("IL BOT HA VINTO!");
          return;
        }
        if (botCard.power == SpecialPower.skip) {
          _botTurn(); 
          return;
        }
      } else {
        // Pesca se non ha mosse
        if (drawPile.isNotEmpty) opponentHand.add(drawPile.removeLast());
      }
      isMyTurn = true;
      _startTimer();
    });
  }

  int _calculateBestBotMove() {
    // 1. Attacco: se l'utente ha poche carte, usa +2 o +4
    if (myHand.length <= 2) {
      int idx = opponentHand.indexWhere((c) => 
        c.canBePlayedOn(lastPlayedCard) && 
        (c.power == SpecialPower.drawTwo || c.power == SpecialPower.wildDrawFour));
      if (idx != -1) return idx;
    }
    // 2. Gioca carte normali dello stesso colore
    int normalIdx = opponentHand.indexWhere((c) => 
      c.canBePlayedOn(lastPlayedCard) && c.color != Colors.black);
    if (normalIdx != -1) return normalIdx;

    // 3. Usa carta nera come ultima risorsa
    return opponentHand.indexWhere((c) => c.canBePlayedOn(lastPlayedCard));
  }

  Color _getBestColorForBot() {
    Map<Color, int> counts = {Colors.red: 0, Colors.blue: 0, Colors.green: 0, Colors.yellow: 0};
    for (var c in opponentHand) {
      if (counts.containsKey(c.color)) counts[c.color] = counts[c.color]! + 1;
    }
    return counts.entries.reduce((a, b) => a.value > b.value ? a : b).key;
  }
